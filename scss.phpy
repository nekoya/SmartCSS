/*
 * SmartCSS yacc
 */

%{
//<?php
$parser = Parser::getInstance();
//$parser->debug = true;
%}
%token LBRACE RBRACE SPACE PLUS GREATER ASTERISK
%token STRING IDENT NUMBER HASH HEXCOLOR PERCENTAGE URI
%token EMS EXS LENGTH ANGLE TIME FREQ
%token IMPORTANT_SYM
%token EXPRESSION
%token ',' ':' ';' '.'

%%

stylesheet
    : rulesets

combinator
    : PLUS s    { $$ = '+'; }
    | GREATER s { $$ = '>'; }
    | SPACE

property
    : IDENT { $$ = Parser::getInstance()->genProperty($1); }

rulesets
    : /* empty */      { $$ = Parser::getInstance()->setTopNode(); }
    | rulesets ruleset { $$ = Parser::getInstance()->catNode($1, $2); }

ruleset
    : selectors LBRACE declarations RBRACE { $$ = Parser::getInstance()->genRuleset($1, $3); }

selectors
    : selector                  { $$ = $1; }
    | selector s ',' s selector { $$ = Parser::getInstance()->catNode($1, $5); }

selector
    : simple_selector                     { $$ = Parser::getInstance()->genSelector($1); }
    | selector combinator simple_selector { $$ = $1; $1->appendValue($2, $3); }

simple_selector
    : element_name
    | attributes
    | element_name attributes { $$ = $1 . $2; }

class
    : '.' IDENT { $$ = chr($1) . $2; }

element_name
    : IDENT
    | ASTERISK

attributes
    : attrib
    | attributes attrib { $$ = $1 . $2; }

attrib
    : class
    | HASH

declarations
    : decl                     { $$ = $1; }
    | declarations follow_decl { $$ = Parser::getInstance()->catNode($1, $2); }

follow_decl : ';' s decl { $$ = $3; }
            | ';'

decl : declaration | ruleset

declaration
    : property ':' s expr { $$ = Parser::getInstance()->genDeclaration($1, $4); }

expr
    : EXPRESSION { $$ = Parser::getInstance()->genExpr($1); }

s : | SPACE

%%

try {
    $lexbuf = file_get_contents('test.css');
    $lexbuf = preg_replace('/^\s*(.*?)\s*$/m', '$1', $lexbuf);
    $lexbuf = preg_replace('/[\r\n]/', '', $lexbuf);
    defineRegexs();
    yyparse();
    $parser = Parser::getInstance();
    echo $parser->run();
} catch (Exception $e) {
    echo $e->getMessage() . "\n";
}

function __autoload($class) {
    $class = preg_replace('/_/', DIRECTORY_SEPARATOR, $class);
    require "libs/$class.class.php";
}

function yylex() {
    global $lexbuf, $yylval, $regexs;
    $parser = Parser::getInstance();

    while ($lexbuf) {
        if (!empty($parser->debug)) {
            //var_dump($lexbuf);
        }

        foreach ($regexs as $token => $regex) {
            $regex = '/^('.$regex.')/i';
            if (preg_match($regex, $lexbuf, $matches)) {
                $yylval = (string)$matches[1];
                $lexbuf = substr($lexbuf, strlen($yylval));
                p($token . ' ' . $yylval);
                if ($token === 'COMMENT') {
                    /* ignore comment */
                    break;
                }
                return constant($token);
            }
        }
        if ($token !== 'COMMENT') {
            $yylval = ord($lexbuf);
            $lexbuf = substr($lexbuf, 1);
            return $yylval;
        }
    }
}

function yyerror($msg) {
    global $lexbuf;
    var_dump($lexbuf);
    die("[error]$msg\n");
}

function p($msg) {
    $parser = Parser::getInstance();
    if (!empty($parser->debug)) {
        echo $msg . "\n";
    }
}

function defineRegexs() {
    global $regexs;
    $regexs = array(
        'LBRACE'        => '\s*{\s*',
        'RBRACE'        => '\s*}\s*',

        'EXPRESSION'    => '?:((?:(?:{{PERCENTAGE}}|{{LENGTH}}|{{EMS}}|{{EXS}}|{{ANGLE}}|{{TIME}}|{{FREQ}}|{{IDENT}}|{{HEXCOLOR}}|{{STRING}}|{{URI}}|{{NUMBER}})\s*)+({{IMPORTANT_SYM}})?)[;}]',
        'COMMENT'       => '\s*\/\*.*?\*\/\s*',
        'STRING'        => '{{string}}',
        'URI'           => 'url\(\s*{{string}}\s*\)',
        'IMPORTANT_SYM' => '!important\s*',

        'EMS'           => '{{num}}em',
        'EXS'           => '{{num}}ex',
        'LENGTH'        => '{{num}}(px|cm|mm|in|pt|pc)',
        'ANGLE'         => '{{num}}(deg|rad|grad)',
        'TIME'          => '{{num}}(ms|s)',
        'FREQ'          => '{{num}}(hz|khz)',

        'HEXCOLOR'      => '#(?:{{h}}{6}|{{h}}{3})',
        'IDENT'         => '{{ident}}',
        'HASH'          => '#{{name}}+',
        'PERCENTAGE'    => '{{num}}+%',
        'NUMBER'        => '{{num}}',
        'PLUS'          => '\s*\+',
        'GREATER'       => '\s*\>',
        'ASTERISK'      => '\*',
        'SPACE'         => '\s+',
    );
    $rules = array(
        'h'       => '[0-9a-f]',
        'ident'   => '-?{{nmstart}}{{nmchar}}*',
        'nmstart' => '[_a-z]',
        'nmchar'  => '[_a-z0-9-]',
        'name'    => '{{nmchar}}+',
        'num'     => '\d*\.{0,1}\d+',
        'string'  => '(?:".*?"|\'.*?\')',
    );
    foreach ($rules as $token => &$regex) {
        while (preg_match('/({{(.+?)}})/', $regex, $matches)) {
            $regex = preg_replace("/$matches[1]/", $rules[$matches[2]], $regex);
        }
    }
    foreach ($regexs as $token => &$regex) {
        while (preg_match('/({{(.+?)}})/', $regex, $matches)) {
            $key = $matches[2];
            if (array_key_exists($key, $rules)) {
                $replace = $rules;
            } else if (array_key_exists($key, $regexs)) {
                $replace = $regexs;
            } else {
                throw new Exception("$key is not defined in lexer.");
            }
            $regex = preg_replace("/$matches[1]/", $replace[$key], $regex);
        }
    }
}
