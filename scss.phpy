/*
 * SmartCSS yacc
 */

%{
//<?php
$parser = Parser::getInstance();
//$parser->debug = true;
%}
%token LBRACE RBRACE SPACE PLUS GREATER ASTERISK
%token IDENT NUMBER HASH HEXCOLOR PERCENTAGE
%token EMS EXS LENGTH ANGLE TIME FREQ
%token ',' ':' ';' '.'

%%

stylesheet
    : rulesets

combinator
    : PLUS s    { $$ = '+'; }
    | GREATER s { $$ = '>'; }
    | SPACE

property
    : IDENT { $$ = Parser::getInstance()->genProperty($1); }

rulesets
    : /* empty */      { $$ = Parser::getInstance()->setTopNode(); }
    | rulesets ruleset { $$ = Parser::getInstance()->catNode($1, $2); }

ruleset
    : selectors LBRACE declarations RBRACE { $$ = Parser::getInstance()->genRuleset($1, $3); }

selectors
    : selector                  { $$ = $1; }
    | selector s ',' s selector { $$ = Parser::getInstance()->catNode($1, $5); }

selector
    : simple_selector                     { $$ = Parser::getInstance()->genSelector($1); }
    | selector combinator simple_selector { $$ = $1; $1->appendValue($2, $3); }

simple_selector
    : element_name
    | attributes
    | element_name attributes { $$ = $1 . $2; }

class
    : '.' IDENT { $$ = chr($1) . $2; }

element_name
    : IDENT
    | ASTERISK

attributes
    : attrib
    | attributes attrib { $$ = $1 . $2; }

attrib
    : class
    | HASH

declarations
    : decl                     { $$ = $1; }
    | declarations follow_decl { $$ = Parser::getInstance()->catNode($1, $2); }

follow_decl : ';' s decl { $$ = $3; }
            | ';'

decl : declaration | ruleset

declaration
    : property ':' s expr { $$ = Parser::getInstance()->genDeclaration($1, $4); }

expr
    : term
    | expr s term { $$ = Parser::getInstance()->catNode($1, $3); }

term
    : NUMBER     { $$ = Parser::getInstance()->genExpr($1); }
    | PERCENTAGE { $$ = Parser::getInstance()->genExpr($1); }
    | LENGTH     { $$ = Parser::getInstance()->genExpr($1); }
    | EMS        { $$ = Parser::getInstance()->genExpr($1); }
    | EXS        { $$ = Parser::getInstance()->genExpr($1); }
    | ANGLE      { $$ = Parser::getInstance()->genExpr($1); }
    | TIME       { $$ = Parser::getInstance()->genExpr($1); }
    | FREQ       { $$ = Parser::getInstance()->genExpr($1); }
    | IDENT      { $$ = Parser::getInstance()->genExpr($1); }
    | HEXCOLOR   { $$ = Parser::getInstance()->genExpr($1); }

s : | SPACE

%%

try {
    $lexbuf = file_get_contents('test.css');
    $lexbuf = preg_replace('/^\s*(.*?)\s*$/m', '$1', $lexbuf);
    $lexbuf = preg_replace('/[\r\n]/', '', $lexbuf);
    yyparse();
    $parser = Parser::getInstance();
    echo $parser->run();
} catch (Exception $e) {
    echo $e->getMessage() . "\n";
}

function __autoload($class) {
    $class = preg_replace('/_/', DIRECTORY_SEPARATOR, $class);
    require "libs/$class.class.php";
}

function yylex() {
    global $lexbuf, $yylval;
    $parser = Parser::getInstance();

    while ($lexbuf) {
        if (!empty($parser->debug)) {
//            var_dump($lexbuf);
        }

        $regexs = array(
            'LBRACE'     => '/^(\s*{\s*)/',
            'RBRACE'     => '/^(\s*}\s*)/',

            'EMS'        => '/^((\d+)em)/',
            'EXS'        => '/^((\d+)ex)/',
            'LENGTH'     => '/^((\d+)(px|cm|mm|in|pt|pc))/',
            'ANGLE'      => '/^((\d+)(deg|rad|grad))/',
            'TIME'       => '/^((\d+)(ms|s))/',
            'FREQ'       => '/^((\d+)(hz|khz))/',

            'COMMENT'    => '/(\/\*.*\*\/)/',
            'HEXCOLOR'   => '/^(#([0-9a-f]{6}|[0-9a-f]{3}))/',
            'IDENT'      => '/^(-?[_a-z][_a-z0-9-]*)/',
            'HASH'       => '/^(#[_a-z0-9-]+)/',
            'PERCENTAGE' => '/^(\d+%)/',
            'NUMBER'     => '/^(\d+)/',
            'PLUS'       => '/^(\s*\+)/',
            'GREATER'    => '/^(\s*\>)/',
            'ASTERISK'   => '/^(\*)/',
            'SPACE'      => '/^(\s+)/',
        );
        foreach ($regexs as $token => $regex) {
            if (preg_match($regex, $lexbuf, $matches)) {
                $yylval = (string)$matches[1];
                $lexbuf = substr($lexbuf, strlen($yylval));
                p($token . ' ' . $yylval);
                if ($token === 'COMMENT') continue; /* ignore comment */
                return constant($token);
            }
        }
        $yylval = ord($lexbuf);
        $lexbuf = substr($lexbuf, 1);
        return $yylval;
    }
}

function yyerror($msg) {
    global $lexbuf;
    var_dump($lexbuf);
    die("[error]$msg\n");
}

function p($msg) {
    $parser = Parser::getInstance();
    if (!empty($parser->debug)) {
        echo $msg . "\n";
    }
}
