/*
 * SmartCSS yacc
 */

%{
//<?php
$parser = Parser::getInstance();
//$parser->debug = true;
%}
%token LBRACE RBRACE SPACE PLUS GREATER ASTERISK
%token STRING IDENT NUMBER HASH HEXCOLOR PERCENTAGE URI
%token EMS EXS LENGTH ANGLE TIME FREQ
%token IMPORTANT_SYM
%token ',' ':' ';' '.'

%%

stylesheet
    : rulesets

combinator
    : PLUS s    { $$ = '+'; }
    | GREATER s { $$ = '>'; }
    | SPACE

property
    : IDENT { $$ = Parser::getInstance()->genProperty($1); }

rulesets
    : /* empty */      { $$ = Parser::getInstance()->setTopNode(); }
    | rulesets ruleset { $$ = Parser::getInstance()->catNode($1, $2); }

ruleset
    : selectors LBRACE declarations RBRACE { $$ = Parser::getInstance()->genRuleset($1, $3); }

selectors
    : selector                  { $$ = $1; }
    | selector s ',' s selector { $$ = Parser::getInstance()->catNode($1, $5); }

selector
    : simple_selector                     { $$ = Parser::getInstance()->genSelector($1); }
    | selector combinator simple_selector { $$ = $1; $1->appendValue($2, $3); }

simple_selector
    : element_name
    | attributes
    | element_name attributes { $$ = $1 . $2; }

class
    : '.' IDENT { $$ = chr($1) . $2; }

element_name
    : IDENT
    | ASTERISK

attributes
    : attrib
    | attributes attrib { $$ = $1 . $2; }

attrib
    : class
    | HASH

declarations
    : decl                     { $$ = $1; }
    | declarations follow_decl { $$ = Parser::getInstance()->catNode($1, $2); }

follow_decl : ';' s decl { $$ = $3; }
            | ';'

decl : declaration | ruleset

declaration
    : property ':' s expr        { $$ = Parser::getInstance()->genDeclaration($1, $4); }
    | property ':' s expr s prio { $$ = Parser::getInstance()->genDeclaration($1, $4, $6); }

prio : IMPORTANT_SYM { $$ = Parser::getInstance()->genPrio($1); }

expr
    : term
    | expr s term { $$ = Parser::getInstance()->catNode($1, $3); }

term
    : NUMBER     { $$ = Parser::getInstance()->genExpr($1); }
    | PERCENTAGE { $$ = Parser::getInstance()->genExpr($1); }
    | LENGTH     { $$ = Parser::getInstance()->genExpr($1); }
    | EMS        { $$ = Parser::getInstance()->genExpr($1); }
    | EXS        { $$ = Parser::getInstance()->genExpr($1); }
    | ANGLE      { $$ = Parser::getInstance()->genExpr($1); }
    | TIME       { $$ = Parser::getInstance()->genExpr($1); }
    | FREQ       { $$ = Parser::getInstance()->genExpr($1); }
    | IDENT      { $$ = Parser::getInstance()->genExpr($1); }
    | HEXCOLOR   { $$ = Parser::getInstance()->genExpr($1); }
    | STRING     { $$ = Parser::getInstance()->genExpr($1); }
    | URI        { $$ = Parser::getInstance()->genExpr($1); }

s : | SPACE

%%

try {
    $lexbuf = file_get_contents('test.css');
    $lexbuf = preg_replace('/^\s*(.*?)\s*$/m', '$1', $lexbuf);
    $lexbuf = preg_replace('/[\r\n]/', '', $lexbuf);
    yyparse();
    $parser = Parser::getInstance();
    echo $parser->run();
} catch (Exception $e) {
    echo $e->getMessage() . "\n";
}

function __autoload($class) {
    $class = preg_replace('/_/', DIRECTORY_SEPARATOR, $class);
    require "libs/$class.class.php";
}

function yylex() {
    global $lexbuf, $yylval;
    $parser = Parser::getInstance();

    while ($lexbuf) {
        if (!empty($parser->debug)) {
            //var_dump($lexbuf);
        }

        $regexs = array(
            'LBRACE'        => '\s*{\s*',
            'RBRACE'        => '\s*}\s*',

            'COMMENT'       => '\s*\/\*.*?\*\/\s*',
            'STRING'        => '\s*(".*?"|\'.*?\')',
            'URI'           => 'url\((\s*(".*?"|\'.*?\'))\s*\)',
            'IMPORTANT_SYM' => '!important\s*',

            'EMS'           => '(\d+)em',
            'EXS'           => '(\d+)ex',
            'LENGTH'        => '(\d+)(px|cm|mm|in|pt|pc)',
            'ANGLE'         => '(\d+)(deg|rad|grad)',
            'TIME'          => '(\d+)(ms|s)',
            'FREQ'          => '(\d+)(hz|khz)',

            'HEXCOLOR'      => '#([0-9a-f]{6}|[0-9a-f]{3})',
            'IDENT'         => '-?[_a-z][_a-z0-9-]*',
            'HASH'          => '#[_a-z0-9-]+',
            'PERCENTAGE'    => '\d+%',
            'NUMBER'        => '\d*\.{0,1}\d+',
            'PLUS'          => '\s*\+',
            'GREATER'       => '\s*\>',
            'ASTERISK'      => '\*',
            'SPACE'         => '\s+',
        );
        foreach ($regexs as $token => $regex) {
            $regex = '/^('.$regex.')/i';
            if (preg_match($regex, $lexbuf, $matches)) {
                $yylval = (string)$matches[1];
                $lexbuf = substr($lexbuf, strlen($yylval));
                p($token . ' ' . $yylval);
                if ($token === 'COMMENT') {
                    /* ignore comment */
                    break;
                }
                return constant($token);
            }
        }
        if ($token !== 'COMMENT') {
            $yylval = ord($lexbuf);
            $lexbuf = substr($lexbuf, 1);
            return $yylval;
        }
    }
}

function yyerror($msg) {
    global $lexbuf;
    var_dump($lexbuf);
    die("[error]$msg\n");
}

function p($msg) {
    $parser = Parser::getInstance();
    if (!empty($parser->debug)) {
        echo $msg . "\n";
    }
}
