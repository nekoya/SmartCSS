/*
 * SmartCSS yacc
 */

%{
//<?php
$parser = Parser::getInstance();
//$parser->debug = true;
%}
%token LBRACE RBRACE SPACE PLUS GREATER ASTERISK
%token IDENT NUMBER HASH HEXCOLOR
%token EMS EXS LENGTH ANGLE TIME FREQ
%token ',' ':' ';' '.'

%%

stylesheet
    : rulesets

rulesets
    : /* empty */      { $$ = Parser::getInstance()->setTopNode(); }
    | rulesets ruleset { $$ = Parser::getInstance()->catNode($1, $2); }

ruleset
    : selectors LBRACE declarations RBRACE { $$ = Parser::getInstance()->genRuleset($1, $3); }

selectors
    : selector              { $$ = $1; }
    | selector s ',' s selector { $$ = Parser::getInstance()->catNode($1, $5); }

combinator
    : PLUS s
    | GREATER s
    | SPACE

selector
    : simple_selector                     { $$ = Parser::getInstance()->genSelector($1); }
    | selector combinator simple_selector { $$ = $1; $1->appendValue($2, $3); }

simple_selector
    : element_name
    | attributes
    | element_name attributes { $$ = $1 . $2; }

element_name
    : IDENT
    | ASTERISK

attributes
    : attr
    | attributes attr { $$ = $1 . $2; }

attr  : class | HASH
class : '.' IDENT { $$ = chr($1) . $2; }

declarations
    : decl                     { $$ = $1; }
    | declarations follow_decl { $$ = Parser::getInstance()->catNode($1, $2); }

follow_decl : ';' s decl { $$ = $3; }
            | ';'

decl : declaration | ruleset

declaration
    : property ':' expr { $$ = Parser::getInstance()->genDeclaration($1, $3); }

property
    : IDENT { $$ = Parser::getInstance()->genProperty($1); }

expr
    : IDENT    { $$ = Parser::getInstance()->genExpr($1); }
    | EMS      { $$ = Parser::getInstance()->genExpr($1); }
    | EXS      { $$ = Parser::getInstance()->genExpr($1); }
    | LENGTH   { $$ = Parser::getInstance()->genExpr($1); }
    | ANGLE    { $$ = Parser::getInstance()->genExpr($1); }
    | TIME     { $$ = Parser::getInstance()->genExpr($1); }
    | FREQ     { $$ = Parser::getInstance()->genExpr($1); }
    | NUMBER   { $$ = Parser::getInstance()->genExpr($1); }
    | HEXCOLOR { $$ = Parser::getInstance()->genExpr($1); }

s : | SPACE

%%

try {
    $lexbuf = file_get_contents('test.css');
    $lexbuf = preg_replace('/^\s*(.*?)\s*$/m', '$1', $lexbuf);
    $lexbuf = preg_replace('/[\r\n]/', '', $lexbuf);
    yyparse();
    $parser = Parser::getInstance();
    echo "----\n";
    echo $parser->run();
} catch (Exception $e) {
    echo $e->getMessage() . "\n";
}

function __autoload($class) {
    $class = preg_replace('/_/', DIRECTORY_SEPARATOR, $class);
    require "libs/$class.class.php";
}

function yylex() {
    global $lexbuf, $yylval;
    $parser = Parser::getInstance();

    while ($lexbuf) {
        if (!empty($parser->debug)) {
//            var_dump($lexbuf);
        }

        $regexs = array(
            'LBRACE'   => '/^(\s*{\s*)/',
            'RBRACE'   => '/^(\s*}\s*)/',

            'EMS'      => '/^((\d+)em)/',
            'EXS'      => '/^((\d+)ex)/',
            'LENGTH'   => '/^((\d+)(px|cm|mm|in|pt|pc))/',
            'ANGLE'    => '/^((\d+)(deg|rad|grad))/',
            'TIME'     => '/^((\d+)(ms|s))/',
            'FREQ'     => '/^((\d+)(hz|khz))/',

            'HEXCOLOR' => '/^(#([0-9a-f]{6}|[0-9a-f]{3}))/',
            'IDENT'    => '/^(-?[_a-z][_a-z0-9-]*)/',
            'HASH'     => '/^(#[_a-z0-9-]+)/',
            'NUMBER'   => '/^(\d+)/',
            'SPACE'    => '/^(\s+)/',
            'PLUS'     => '/^(\+)/',
            'GREATER'  => '/^(\>)/',
            'ASTERISK' => '/^(\*)/',
        );
        foreach ($regexs as $token => $regex) {
            if (preg_match($regex, $lexbuf, $matches)) {
                $yylval = (string)$matches[1];
                $lexbuf = substr($lexbuf, strlen($yylval));
                p($token . ' ' . $yylval);
                return constant($token);
            }
        }
        $yylval = ord($lexbuf);
        $lexbuf = substr($lexbuf, 1);
        return $yylval;
    }
}

function yyerror($msg) {
    global $lexbuf;
    var_dump($lexbuf);
    die("[error]$msg\n");
}

function p($msg) {
    $parser = Parser::getInstance();
    if (!empty($parser->debug)) {
        echo $msg . "\n";
    }
}
